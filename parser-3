from Lexer import TokenType

'''
expr         ::= implication ;

implication  ::= neg_expr [ "=>" implication ] ;

neg_expr     ::= "~" neg_expr | or_expr ;

or_expr      ::= and_expr { "|" and_expr } ;

and_expr     ::= last { "&" last } ;

last         ::= "true" | "false" | "(" expr ")" ;

'''

class Parser:
    def __init__(self, lexer):
        self.lexer = lexer
        try:
            self.current_token = self.lexer.next_token()
        except ValueError as e:
            raise SyntaxError(str(e))

    def consume(self, expected_token_type):
        if self.current_token.type == expected_token_type:
            try:
                self.current_token = self.lexer.next_token()
            except ValueError as e:
                raise SyntaxError(str(e))
        else:
            raise SyntaxError(
                f"Syntax error: expected token type {expected_token_type}, "
                f"but found token type {self.current_token.type}"
            )

    def parse(self):
        result = self.parse_impl()
        if self.current_token.type != TokenType.EOF:
            raise SyntaxError(f"Syntax error: expected EOF, but found {self.current_token.type}")
        return result

    def parse_impl(self):
        left = self.parse_neg()
        if self.current_token.type == TokenType.IMPL:
            self.consume(TokenType.IMPL)
            right = self.parse_impl()
            return (not left) or right
        return left

    def parse_neg(self):
        if self.current_token.type == TokenType.NEG:
            self.consume(TokenType.NEG)
            return not self.parse_neg()
        else:
            return self.parse_or()

    def parse_or(self):
        left = self.parse_and()
        while self.current_token.type == TokenType.OR:
            self.consume(TokenType.OR)
            right = self.parse_and()
            left = left or right
        return left

    def parse_and(self):
        left = self.last()
        while self.current_token.type == TokenType.AND:
            self.consume(TokenType.AND)
            right = self.last()
            left = left and right
        return left

    def last(self):
        if self.current_token.type == TokenType.CONST:
            value = self.current_token.attribute
            self.consume(TokenType.CONST)
            return value == "true"
        elif self.current_token.type == TokenType.LPAREN:
            self.consume(TokenType.LPAREN)
            value = self.parse_impl()
            self.consume(TokenType.RPAREN)
            return value
        else:
            raise SyntaxError(
                f"Syntax error: expected token type TokenType.CONST or TokenType.LPAREN, "
                f"but found token type {self.current_token.type}"
            )
