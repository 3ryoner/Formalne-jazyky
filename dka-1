#   {ab | c[a]}b

from enum import Enum, auto

class TokenType(Enum):
    A = auto()
    B = auto()
    C = auto()
    EOF = auto()

class Token:
    def __init__(self, type):
        self.type = type

class Lexer:
    def __init__(self, input_text):
        self.input = input_text
        self.pos = 0

    def get_next_token(self):
        if self.pos >= len(self.input):
            return Token(TokenType.EOF)

        char = self.input[self.pos]
        self.pos += 1

        if char == 'a':
            return Token(TokenType.A)
        elif char == 'b':
            return Token(TokenType.B)
        elif char == 'c':
            return Token(TokenType.C)
        else:
            raise ValueError(f"Invalid character: {char}")

class DKA:
    def __init__(self):
        self.lexer = None
        self.current_token = None

    def consume(self, expected_type):
        if self.current_token.type == expected_type:
            self.current_token = self.lexer.get_next_token()
        else:
            raise SyntaxError(f"Expected {expected_type}, got {self.current_token.type}")

    def check(self, word):
        try:
            self.lexer = Lexer(word)
            self.current_token = self.lexer.get_next_token()
            if len(word) == 0:
                return False

            self.rec()

            if self.current_token.type != TokenType.B:
                return False
            self.consume(TokenType.B)

            return self.current_token.type == TokenType.EOF

        except (SyntaxError, ValueError):
            return False

    def rec(self):
        if self.lexer.pos >= len(self.lexer.input):
            return

        if self.current_token.type == TokenType.A:
            self.consume(TokenType.A)
            if self.current_token.type != TokenType.B:
                return False
            self.consume(TokenType.B)
        elif self.current_token.type == TokenType.C:
            self.consume(TokenType.C)
            if self.current_token.type == TokenType.A:
                self.consume(TokenType.A)
        else: raise SyntaxError(f"Expected {TokenType.A}, got {self.current_token.type}")

        self.rec()